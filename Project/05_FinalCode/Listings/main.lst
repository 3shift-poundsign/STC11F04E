C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\install\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include<reg51.h>
   2          #include <intrins.h>
   3          #define uchar unsigned char
   4          #define uint unsigned int
   5          #define dec(dat) ((dat>>4)*10+(dat&0x0f))     // BCD码转十进制
   6          
   7          sbit IO = P1^4;         // DS1302 数据输入输出线
   8          sbit RST = P1^6;        // DS1302 复位信号线
   9          sbit SCLK = P1^5;       // DS1302 时钟信号线
  10          sbit DS = P1^7;         // DS18B20 数据端口
  11          sbit DAT = P3^0;        // 74HC164 数据输入端口
  12          sbit CLK = P3^1;        // 74HC164 时钟输入端口
  13          sbit DP = P3^7;         // 时间分割点
  14          sbit DP1 = P3^5;        // 温度小数点
  15          sbit KEY = P3^2;        // 按键INT0
  16          uint flag = 0;          // 时间小数点闪烁计数
  17          uint temp;              // 温度变量
  18          
  19          uchar code write_addr[]={0x80,0x82,0x84,0x86,0x88,0x8a,0x8c};   // DS1302写地址
  20          uchar code read_addr[]={0x81,0x83,0x85,0x87,0x89,0x8b,0x8d};    // DS1302读地址
  21          
  22          // 定义数码管段选(不加小数点0~9、℃)
  23          uchar code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82,0xA9};
  24          
  25          // 存储顺序是秒分时日月周年,存储格式是用BCD码
  26          uchar time[7]={0,0x55,0x18,0x04,0x10,0x05,0x19};  //初始化的时间为2019年10月4日18:55:00
  27          
  28          
  29          
  30          /**********************************************************
  31          *  函数名称：低精度延时函数
  32          *  日期：2019-9-7
  33          *  姓名：ZhangHJ
  34          *  说明：嵌套循环延时
  35          ***********************************************************/
  36          void delay(unsigned int mstime)
  37          {
  38   1        int i,j;
  39   1        for(i=mstime; i>=0; i--)
  40   1          for(j=114; j>=0; j--);
  41   1      }
  42          
  43          
  44          
  45          /**********************************************************
  46          *  函数名称：74HC164发送Byte数据函数
  47          *  日期：2019-9-29
  48          *  姓名：ZhangHJ
  49          *  说明：74HC164移位寄存器输入一字节数据发给寄存器
  50          ***********************************************************/
  51          void SendByte_74HC164(uchar byte)
  52          {
  53   1        uchar num,c;
  54   1        num=table1[byte];
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 2   

  55   1        for(c=0; c<8; c++)
  56   1        {
  57   2          DAT=num&0x01;   // P3^0 --> 0000 000x
  58   2          CLK=0;          // 制造一个上升沿
  59   2          CLK=1;
  60   2          num>>=1;        // 将数据发送到寄存器
  61   2        }
  62   1      }
  63          
  64          
  65          
  66          /**********************************************************
  67          *  函数名称：DS18B20发送复位和初始化命令函数
  68          *  修改日期：2019-9-9
  69          *  修改人：ZhangHJ
  70          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  71          *           释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  72          *           如果出现低电平，说明器件应答正常.B
  73          *        2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
  74          *           如果有低电平,在总线释放之后，等待15-60us,
  75          *           将电平拉低60-240us,告诉主机已经准备好.
  76          ***********************************************************/
  77          uchar dsreset(void)         // send reset and initialization command
  78          {
  79   1        uint i;
  80   1        DS = 0;                   // 先将端口拉低
  81   1        i=120;                    // 维持低电平状态480us~960us
  82   1        while(i>0)i--;
  83   1        DS = 1;                   // 然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
  84   1        // 等待DS18B20响应
  85   1        i = 0;
  86   1        while(DS)                 // 在DS高电平时等待
  87   1        {
  88   2          i++;
  89   2          if(i > 50000)           // 等待时间大于60us,说明响应失败
  90   2          {
  91   3            return 0;
  92   3          }
  93   2        }
  94   1        return 1;
  95   1      }
  96          
  97          
  98          
  99          /**********************************************************
 100          *  函数名称：DS18B20读1bit数据函数
 101          *  修改日期：2019-9-9
 102          *  修改人：ZhangHJ
 103          *  说明：1.首先单片机端口拉低 1 us (i++),
 104          *        2.然后释放总线,拉高总线,
 105          *        3.等待几位秒，是为了让 DS18B20 数据稳定,
 106          *        4.在15 us 内读取DS数据,
 107          *        5.接下来进行延时等待采样周期完成。
 108          *        详见DS18B20资料2.8.3.1读/写时间片
 109          ***********************************************************/
 110          bit tmpreadbit(void)        // read a bit data
 111          {
 112   1        uint i;
 113   1        bit dat;                  // 定义位数据 (dat = 0 or 1)
 114   1        DS = 0;                   // 先将端口拉低
 115   1        _nop_();                  // 延时 2us ,要求至少保持1us
 116   1        DS = 1;                   // 再将端口拉高
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 3   

 117   1        i=8;while(i>0)i--;        // 等待DS数据稳定,要求的至少延时15us以上
 118   1        dat = DS;                 // 数据传输
 119   1        i=15;while(i>0)i--;       // 等待数据采样周期完成,要求不低于60us
 120   1        return (dat);
 121   1      }
 122          
 123          
 124          
 125          /**********************************************************
 126          *  函数名称：DS18B20读1Byte数据函数
 127          *  修改日期：2019-9-9
 128          *  修改人：ZhangHJ
 129          *  说明：1.首先初始化字节数据变量dat为 0
 130          *        2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 131          *        3.读出的数据暂存到 j ,之后进行移位和按位或操作
 132          *        4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 133          *        5.最后返回读到的字节数据
 134          ***********************************************************/
 135          uchar tmpread(void)         // read a byte date
 136          {
 137   1        uchar i,j,dat;
 138   1        dat = 0;                  // 初始化数据变量为 0
 139   1        for(i=1;i<=8;i++)         // 循环 8 次,调用tmpreadbit函数,读 8bit 数据
 140   1        {
 141   2          j = tmpreadbit();       // 读出的数据暂存到 j
 142   2          dat = (j<<7)|(dat>>1);  // 效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 143   2        }
 144   1        return(dat);              // 返回读到的字节
 145   1      }
 146          
 147          
 148          
 149          /**********************************************************
 150          *  函数名称：DS18B20写入1Byte数据函数
 151          *  修改日期：2019-9-11
 152          *  修改人：ZhangHJ
 153          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 154          *        2.通过判断testb得到写 0 还是写 1
 155          *        3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 156          *        4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 157          *        5.循环执行2、3、4操作8次,写入1字节数据
 158          *        详见18B20资料“2.8.3.1读/写时间片”章节
 159          ***********************************************************/
 160          void tmpwritebyte(uchar dat)   //write a byte to ds18b20
 161          {
 162   1        uint i;
 163   1        uchar j;
 164   1        bit testb;
 165   1        for(j=1;j<=8;j++)
 166   1        {
 167   2          testb = dat&0x01;
 168   2          dat = dat>>1;
 169   2          if(testb)                 // write 1
 170   2          {
 171   3            DS=0;
 172   3            i=8;while(i>0)i--;;     // 延时要求15~60us内
 173   3            DS=1;
 174   3            i=15;while(i>0)i--;     // 要求不低于60us
 175   3          }
 176   2          else
 177   2          {
 178   3            DS = 0;                 // write 0
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 4   

 179   3            i=15;while(i>0)i--;
 180   3            DS = 1;
 181   3            i++;i++;
 182   3          }
 183   2        }
 184   1      }
 185          
 186          
 187          
 188          /**********************************************************
 189          *  函数名称：DS18B20温度转换函数
 190          *  修改日期：2019-9-11
 191          *  修改人：ZhangHJ
 192          *  说明：1.首先进行18B20初始化
 193          *        2.进行适当延时
 194          *        3.发送跳过光刻ROM指令
 195          *        4.发送RAM指令,进行温度转换
 196          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 197          ***********************************************************/
 198          void tmpchange(void)          // DS18B20 begin change
 199          {
 200   1        while(dsreset() == 0)
 201   1        {
 202   2          SendByte_74HC164(0);
 203   2          P1 &= 0xfB;
 204   2        }
 205   1        delay(1);
 206   1        tmpwritebyte(0xCC);         // 跳过 ROM 操作
 207   1        tmpwritebyte(0x44);         // 启动一次温度转换
 208   1      }
 209          
 210          
 211          
 212          /**********************************************************
 213          *  函数名称：DS18B20温度转换完整过程函数
 214          *  修改日期：2019-9-11
 215          *  修改人：ZhangHJ
 216          *  说明：1.首先进行18B20初始化
 217          *        2.进行适当延时
 218          *        3.发送跳过光刻ROM指令
 219          *        4.发送RAM指令,进行温度转换
 220          *        5.读取两个8位数据,放到16位寄存器 temp 中
 221          *        6.将读取到的二进制数据(默认为正数),转换为十进制数据
 222          *        7.返回温度数据
 223          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 224          ***********************************************************/
 225          uint tmp()                    // get the temperature
 226          {
 227   1        float tt;
 228   1        uchar high,low;
 229   1        //P1 |= 0x0f;
 230   1        while(dsreset() == 0)
 231   1        {
 232   2          SendByte_74HC164(0);
 233   2          P1 &= 0xfB;
 234   2        }
 235   1        delay(1);
 236   1        //tmpchange();
 237   1        tmpwritebyte(0xCC);         // 跳过 ROM 操作
 238   1        tmpwritebyte(0xBE);         // 读暂存寄存器
 239   1        low=tmpread();
 240   1        high=tmpread();
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 5   

 241   1        temp=high;
 242   1        temp<<=8;                   // two byte compose a int variable
 243   1        temp=temp|low;
 244   1        tt=temp*0.0625;
 245   1        temp=tt*10+0.5;
 246   1        return temp;
 247   1      }
 248          
 249          
 250          
 251          /**********************************************************
 252          *  函数名称：数码管温度数据显示函数
 253          *  修改日期：2019-9-11
 254          *  修改人：ZhangHJ
 255          *  说明：1.temp表示需要显示的温度数值(百位数值)
 256          *        2.A1、A2、A3分别了百位、十位、个位数值
 257          *        3.控制段选信号dula和位选信号wela,以使数码管显示
 258          ***********************************************************/
 259          void Display_Tmp(uint temp)       // 显示程序
 260          {
 261   1        uchar A1,A2,A2t,A3,ser;
 262   1        ser=temp/10;
 263   1        SBUF=ser;
 264   1        A1=temp/100;                // A1 --> 百位
 265   1        A2t=temp%100;               // A2t --> 后两位
 266   1        A2=A2t/10;                  // A2 --> 十位
 267   1        A3=A2t%10;                  // A3 --> 个位
 268   1        
 269   1        DP1 = 0;                    // 温度小数点开启
 270   1        DP = 1;                     // 时间小数点关闭
 271   1         
 272   1        // 控制数码管显示温度数值
 273   1        P1 |= 0x0f;
 274   1        SendByte_74HC164(A1);
 275   1        P1 &= 0xfB;
 276   1        delay(6);
 277   1        P1 |= 0x0f;
 278   1        
 279   1        SendByte_74HC164(A2);
 280   1        P1 &= 0xfD;
 281   1        delay(6);
 282   1        P1 |= 0x0f;
 283   1        
 284   1        SendByte_74HC164(A3);
 285   1        P1 &= 0xfE;
 286   1        delay(6);
 287   1        P1 |= 0x0f;
 288   1        
 289   1        SendByte_74HC164(10);
 290   1        P1 &= 0xf7;
 291   1        delay(6);
 292   1        P1 |= 0x0f;
 293   1      }
 294          
 295          
 296          
 297          /**********************************************************
 298          *  函数名称：DS1302写操作函数
 299          *  日期：2019-10-4
 300          *  姓名：ZhangHJ
 301          *  说明：写操作包含两个参数,add表示要写入的地址;wdata表示要写入的数据
 302          *        1. 读写操作需要先将RST拉高才能进行
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 6   

 303          *        2. 先写入控制字节,在时钟上升沿串行写入数据
 304          *        3. 再写入数据字节,同样在时钟上升沿写入数据
 305          *        4. 最后拉低RST禁止数据传输
 306          ***********************************************************/
 307          void DS1302Write(uchar add,uchar wdata)
 308          {
 309   1        uchar a;
 310   1        //wdata = hex(wdata);   // 转换为BCD码
 311   1        RST=0;                  // 拉低RST引脚,终止数据传输
 312   1        SCLK=0;                 // 拉低SCLK引脚,清零时钟线
 313   1        RST=1;                  // 拉高RST引脚,所有数据传输都要拉高RST脚,启动控制逻辑
 314   1        //先写入控制字节
 315   1        for(a=0; a<8; a++)
 316   1        {
 317   2            IO= add & 0x01;     // IO引脚准备好要写入的1位数据
 318   2            SCLK=1;             // SCLK上升沿,1位数据从IO脚写入,低位先写入
 319   2            add>>=1;            // 数据右移1位
 320   2            SCLK=0;             // 拉低SCLK,为下次写入准备,循环8次写入1字节
 321   2        }
 322   1        //再写入数据字节
 323   1        for(a=0; a<8; a++)
 324   1        {
 325   2            IO= wdata & 0x01;
 326   2            SCLK=1;
 327   2            wdata>>=1;
 328   2            SCLK=0;
 329   2        }
 330   1        RST=0;                  // 数据传输完拉低RST
 331   1      }  
 332          
 333          
 334          
 335          /**********************************************************
 336          *  函数名称：DS1302读操作函数
 337          *  日期：2019-10-4
 338          *  姓名：ZhangHJ
 339          *  说明：读操作只需一个参数,即需要读取的寄存器地址add
 340          *        1. 首先需要将需要读取的地址(1Byte)写入寄存器,在上升沿进行写入操作
 341          *        2. 之后读取该地址中的数据,在下降沿读取数据
 342          *        3. 最后返回读取到的1Byte数据
 343          ***********************************************************/ 
 344          uchar DS1302Read(uchar add)
 345          {
 346   1        uchar a, rdata=0;
 347   1        RST = 0;                      // 拉低RST引脚,终止数据传输
 348   1        SCLK = 0;                     // 拉低SCLK引脚,清零时钟线
 349   1        RST = 1;                      // 拉高RST引脚,启动控制逻辑
 350   1        //发送控制字节
 351   1        for(a=0; a<8; a++)
 352   1        {
 353   2          SCLK = 0;
 354   2          IO = add & 0x01;
 355   2          SCLK = 1;                   // 制造一个上升沿,写入地址
 356   2          add >>= 1;
 357   2        }
 358   1        //读1字节数据
 359   1        for(a=0; a<8; a++)
 360   1        {
 361   2          SCLK = 1;
 362   2          rdata >>= 1;
 363   2          SCLK = 0;                   // 制造一个下降沿,读取数据
 364   2          if(IO)
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 7   

 365   2          {                           // 如果读到1
 366   3            rdata |= 0x80;            // 把最高位置为1,记录到rdata中
 367   3          }
 368   2        }
 369   1        RST=0;                        // 拉低RST
 370   1        //return dec(d);              // 读取的数据转换成十进制
 371   1        return rdata;
 372   1      }
 373          
 374          
 375          
 376          /**********************************************************
 377          *  函数名称：DS1302初始化函数
 378          *  日期：2019-10-4
 379          *  姓名：ZhangHJ
 380          *  说明：初始化即为对DS1302初始数据的写入
 381          *        1. 首先需要关闭写保护,以允许数据写入
 382          *        2. 之后按"秒分时日月周年"的顺序写入初始数据
 383          *        3. 最后开启写保护,禁止数据写入
 384          ***********************************************************/ 
 385          void ds1302_init()
 386          {
 387   1         uchar k;
 388   1         DS1302Write(0x8e,0x00);      // 禁止写保护，即允许数据写入
 389   1         for(k=0;k<7;k++)             // 写入7个字节的时钟信号：秒分时日月周年
 390   1         {
 391   2           DS1302Write(write_addr[k],time[k]);
 392   2         }
 393   1         DS1302Write(0x8e,0x80);      // 打开写保护,禁止数据写入
 394   1      }
 395          
 396          
 397          
 398          
 399          /**********************************************************
 400          *  函数名称：DS1302数据读取函数
 401          *  日期：2019-10-4
 402          *  姓名：ZhangHJ
 403          *  说明：数据读取即为按寄存器地址读取数据的过程
 404          *        直接按地址读取寄存器中的数据,然后将数据放到time数组里保存即可
 405          ***********************************************************/ 
 406          void read_time()
 407          {
 408   1         uchar n;
 409   1         for(n=0;n<7;n++)
 410   1          time[n]=DS1302Read(read_addr[n]);   //读取秒分时日月周年
 411   1      }
 412          
 413          
 414          
 415          /**********************************************************
 416          *  函数名称：数码管时间数据显示函数
 417          *  修改日期：2019-10-4
 418          *  修改人：ZhangHJ
 419          *  说明：1. A0~A9表示从秒到月的时间数值,按此规律可以计算到年
 420          *        2. DP表示时间分割的小数点,低电平选中
 421          *        3. 最后通过控制位选和段选点亮数码管,显示时间
 422          ***********************************************************/
 423          void Display_Time()             // 显示程序
 424          {
 425   1        uchar A0,A1,A2,A3,A4,A5,A6,A7,A8,A9;
 426   1        A0 = dec(time[0])/10;         // A0-->秒十位
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 8   

 427   1        A1 = dec(time[0])%10;         // A1-->秒个位
 428   1        A2 = dec(time[1])/10;         // A2-->分十位
 429   1        A3 = dec(time[1])%10;         // A3-->分个位
 430   1        A4 = dec(time[2])/10;         // A4-->时十位
 431   1        A5 = dec(time[2])%10;         // A5-->时个位
 432   1        A6 = dec(time[3])/10;         // A6-->日十位
 433   1        A7 = dec(time[3])%10;         // A7-->日个位
 434   1        A8 = dec(time[3])/10;         // A8-->月十位
 435   1        A9 = dec(time[3])%10;         // A9-->月个位
 436   1        
 437   1        DP1 = 1;                      // 温度小数点关闭
 438   1        flag ++;                      // 时间点闪烁计数
 439   1        if(flag >= 134)
 440   1        {
 441   2          DP = ~DP;
 442   2          flag = 0;
 443   2        }
 444   1         
 445   1        // 控制数码管显示温度数值
 446   1        P1 |= 0x0f;
 447   1        SendByte_74HC164(A4);         // A4-->时十位
 448   1        P1 &= 0xf7;
 449   1        delay(6);
 450   1        P1 |= 0x0f;
 451   1        
 452   1        SendByte_74HC164(A5);         // A5-->时个位
 453   1        P1 &= 0xfB;
 454   1        delay(6);
 455   1        P1 |= 0x0f;
 456   1        
 457   1        SendByte_74HC164(A2);         // A2-->分十位
 458   1        P1 &= 0xfd;
 459   1        delay(6);
 460   1        P1 |= 0x0f;
 461   1        
 462   1        SendByte_74HC164(A3);         // A3-->分个位
 463   1        P1 &= 0xfe;
 464   1        delay(6);
 465   1        P1 |= 0x0f;
 466   1      }
 467          
 468          
 469          
 470          // 主函数功能：默认显示时间(初始化时间为“2019年10月4日18:55:00”),按住INT0按键时,会显示温度
 471          void main()
 472          {
 473   1        uchar a;
 474   1        ds1302_init();                  // DS1302日期初始化
 475   1        while(1)
 476   1        {
 477   2          // 时间显示
 478   2          read_time();                  // DS1302读取当前时间
 479   2          Display_Time();               // 显示当前时间
 480   2          // 按键处理
 481   2          if (KEY == 0)
 482   2          {
 483   3            delay(5);
 484   3            while(KEY == 0)             // 按键消抖
 485   3            {
 486   4              // 温度显示
 487   4              tmpchange();              // 首次温度转换
 488   4              for(a=50;a>0;a--)         // 延时,保持连续显示
C51 COMPILER V9.57.0.0   MAIN                                                              10/04/2019 20:36:05 PAGE 9   

 489   4              {
 490   5                Display_Tmp(tmp());     // 进行温度转换和数值显示
 491   5              }
 492   4            }
 493   3          }
 494   2        }
 495   1      }
 496          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1054    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     11      14
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
