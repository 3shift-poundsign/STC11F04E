C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\install\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #define uchar unsigned char
   3          #define uint unsigned int
   4          sbit DS = P1^7;         //define interface
   5          uint temp;              //variable of temperature
   6          //uchar flag1;            //sign of the result positive or negative
   7          sbit DAT = P3^0;
   8          sbit CLK = P3^1;
   9          
  10          //定义数码管段选(不加小数点0~9)
  11          unsigned char code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82};
  12          
  13          
  14          
  15          /**********************************************************
  16          *  函数名称：延时函数
  17          *  修改日期：2019-9-9
  18          *  修改人：ZhangHJ
  19          *  说明：低精度延时函数
  20          ***********************************************************/
  21          void delay(uint count)  //delay function
  22          {
  23   1        uint i;
  24   1        while(count)
  25   1        {
  26   2          i=200;
  27   2          while(i>0) i--;
  28   2          count--;
  29   2        }
  30   1      }
  31          
  32          
  33          
  34          /**********************************************************
  35          *  函数名称：低精度延时函数
  36          *  日期：2019-9-7
  37          *  姓名：ZhangHJ
  38          *  说明：嵌套循环延时
  39          ***********************************************************/
  40          void delay_ms(unsigned int mstime)
  41          {
  42   1        int i,j;
  43   1        for(i=mstime; i>=0; i--)
  44   1          for(j=112; j>=0; j--);
  45   1      }
  46          
  47          
  48          
  49          /**********************************************************
  50          *  函数名称：74HC164发送Byte函数
  51          *  日期：2019-9-29
  52          *  姓名：ZhangHJ
  53          *  说明：74HC164移位寄存器输入一字节数据发给寄存器
  54          ***********************************************************/
C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 2   

  55          void SendByte_74HC164(uchar byte)
  56          {
  57   1        uchar num,c;
  58   1        num=table1[byte];
  59   1        for(c=0; c<8; c++)
  60   1        {
  61   2          DAT=num&0x01;   // P3^0 --> 0000 000x
  62   2          CLK=0;          // 制造一个上升沿
  63   2          CLK=1;
  64   2          num>>=1;        // 将数据发送到寄存器
  65   2        }
  66   1      }
  67          
  68          
  69          /**********************************************************
  70          *  函数名称：发送复位和初始化命令函数 dsinit
  71          *  修改日期：2019-9-9
  72          *  修改人：ZhangHJ
  73          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  74          *           释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  75          *           如果出现低电平，说明器件应答正常.B
  76          *        2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
  77          *           如果有低电平,在总线释放之后，等待15-60us,
  78          *           将电平拉低60-240us,告诉主机已经准备好.
  79          ***********************************************************/
  80          uchar dsreset(void)       //send reset and initialization command
  81          {
  82   1        uint i;
  83   1        DS = 0;               //先将端口拉低
  84   1        i=150;                  //维持低电平状态480us~960us
  85   1        while(i>0)i--;
  86   1        DS = 1;               //然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
  87   1      //  i = 4;              //15us~60us等待
  88   1      //  while(i>0)i--;
  89   1      
  90   1        i = 0;
  91   1        while(DS)             //在DS高电平时等待
  92   1        {
  93   2          i++;
  94   2          if(i > 50000)       //等待时间大于60us,说明响应失败
  95   2          {
  96   3            return 0;
  97   3          }
  98   2        }
  99   1        return 1;
 100   1      }
 101          
 102          
 103          
 104          /**********************************************************
 105          *  函数名称：读1bit数据函数
 106          *  修改日期：2019-9-9
 107          *  修改人：ZhangHJ
 108          *  说明：1.首先单片机端口拉低 1 us (i++),
 109          *        2.然后释放总线,拉高总线,
 110          *        3.等待几位秒，是为了让 DS18B20 数据稳定,
 111          *        4.在15 us 内读取DS数据,
 112          *        5.接下来进行延时等待采样周期完成。
 113          *        详见DS18B20资料2.8.3.1读/写时间片
 114          ***********************************************************/
 115          bit tmpreadbit(void)    //read a bit data
 116          {
C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 3   

 117   1        uint i;
 118   1        bit dat;              //定义位数据 (dat = 0 or 1)
 119   1        DS = 0;               //先将端口拉低
 120   1        i++;                  //延时 1us
 121   1        DS = 1;               //再将端口拉高
 122   1        i++;i++;              //等待DS数据稳定
 123   1        dat = DS;             //数据传输
 124   1        i=8;while(i>0)i--;    //等待数据采样周期完成
 125   1        return (dat);
 126   1      }
 127          
 128          
 129          
 130          /**********************************************************
 131          *  函数名称：读1Byte数据函数
 132          *  修改日期：2019-9-9
 133          *  修改人：ZhangHJ
 134          *  说明：1.首先初始化字节数据变量dat为 0
 135          *        2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 136          *        3.读出的数据暂存到 j ,之后进行移位和按位或操作
 137          *        4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 138          *        5.最后返回读到的字节数据
 139          ***********************************************************/
 140          uchar tmpread(void)         //read a byte date
 141          {
 142   1        uchar i,j,dat;
 143   1        dat = 0;                  //初始化数据变量为 0
 144   1        for(i=1;i<=8;i++)         //循环 8 次,调用tmpreadbit函数,读 8bit 数据
 145   1        {
 146   2          j = tmpreadbit();       //读出的数据暂存到 j
 147   2          dat = (j<<7)|(dat>>1);  //效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 148   2        }
 149   1        return(dat);              //返回读到的字节
 150   1      }
 151          
 152          
 153          
 154          /**********************************************************
 155          *  函数名称：写入1Byte数据函数
 156          *  修改日期：2019-9-11
 157          *  修改人：ZhangHJ
 158          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 159          *        2.通过判断testb得到写 0 还是写 1
 160          *        3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 161          *        4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 162          *        5.循环执行2、3、4操作8次,写入1字节数据
 163          *        详见18B20资料“2.8.3.1读/写时间片”章节
 164          ***********************************************************/
 165          void tmpwritebyte(uchar dat)   //write a byte to ds18b20
 166          {
 167   1        uint i;
 168   1        uchar j;
 169   1        bit testb;
 170   1        for(j=1;j<=8;j++)
 171   1        {
 172   2          testb = dat&0x01;
 173   2          dat = dat>>1;
 174   2          if(testb)                 //write 1
 175   2          {
 176   3            DS=0;
 177   3            i++;i++;
 178   3            DS=1;
C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 4   

 179   3            i=8;while(i>0)i--;
 180   3          }
 181   2          else
 182   2          {
 183   3            DS = 0;                 //write 0
 184   3            i=8;while(i>0)i--;
 185   3            DS=1;
 186   3            i++;i++;
 187   3          }
 188   2        }
 189   1      }
 190          
 191          
 192          
 193          /**********************************************************
 194          *  函数名称：18B20温度转换函数
 195          *  修改日期：2019-9-11
 196          *  修改人：ZhangHJ
 197          *  说明：1.首先进行18B20初始化
 198          *        2.进行适当延时
 199          *        3.发送跳过光刻ROM指令
 200          *        4.发送RAM指令,进行温度转换
 201          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 202          ***********************************************************/
 203          void tmpchange(void)          //DS18B20 begin change
 204          {
 205   1        while(dsreset() == 0)
 206   1        {
 207   2          SendByte_74HC164(0);
 208   2          P1 &= 0xfB;
 209   2        }
 210   1        delay_ms(1);
 211   1        tmpwritebyte(0xcc);         //address all drivers on bus
 212   1        tmpwritebyte(0x44);         //initiates a single temperature conversion
 213   1        //delay(100);               //not wait to change finish
 214   1      }
 215          
 216          
 217          
 218          /**********************************************************
 219          *  函数名称：18B20温度转换完整过程函数
 220          *  修改日期：2019-9-11
 221          *  修改人：ZhangHJ
 222          *  说明：1.首先进行18B20初始化
 223          *        2.进行适当延时
 224          *        3.发送跳过光刻ROM指令
 225          *        4.发送RAM指令,进行温度转换
 226          *        5.读取两个8位数据,放到16位寄存器 temp 中
 227          *        6.将读取到的二进制数据(默认为正数),转换为十进制数据
 228          *        7.返回温度数据
 229          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 230          ***********************************************************/
 231          uint tmp()                    //get the temperature
 232          {
 233   1        float tt;
 234   1        uchar a,b;
 235   1        //P1 |= 0x0f;
 236   1        while(dsreset() == 0)
 237   1        {
 238   2          SendByte_74HC164(0);
 239   2          P1 &= 0xfB;
 240   2        }
C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 5   

 241   1        delay_ms(1);
 242   1        tmpwritebyte(0xcc);         //读暂存寄存器
 243   1        tmpwritebyte(0xbe);
 244   1        a=tmpread();
 245   1        b=tmpread();
 246   1        delay_ms(10);
 247   1        temp=b;
 248   1        temp<<=8;                   //two byte compose a int variable
 249   1        temp=temp|a;
 250   1        tt=temp*0.0625;
 251   1        temp=tt*10+0.5;
 252   1        
 253   1        return temp;
 254   1      }
 255          
 256          
 257          
 258          /**********************************************************
 259          *  函数名称：读取ROM函数
 260          *  修改日期：2019-9-11
 261          *  修改人：ZhangHJ
 262          *  说明：使单片机读取DS18B20产品的序列号,暂时没有用到
 263          *        详见18B20资料“2.8.2.2ROM操作命令”章节
 264          ***********************************************************/
 265          //void readrom()                //read the serial
 266          //{
 267          //  uchar sn1,sn2;
 268          //  dsreset();
 269          //  delay(1);
 270          //  tmpwritebyte(0x33);
 271          //  sn1=tmpread();
 272          //  sn2=tmpread();
 273          //}
 274          
 275          
 276          
 277          /**********************************************************
 278          *  函数名称：10ms延时函数
 279          *  修改日期：2019-9-11
 280          *  修改人：ZhangHJ
 281          *  说明：延时10ms
 282          *        详见18B20资料“2.8.2.2ROM操作命令”章节
 283          ***********************************************************/
 284          //void delay10ms()              //delay 10ms
 285          //{
 286          //  uchar a,b;
 287          //  for(a=10;a>0;a--)
 288          //    for(b=60;b>0;b--);
 289          //}
 290          
 291          
 292          
 293          /**********************************************************
 294          *  函数名称：数码管温度数据显示函数
 295          *  修改日期：2019-9-11
 296          *  修改人：ZhangHJ
 297          *  说明：1.temp表示需要显示的温度数值(百位数值)
 298          *        2.A1、A2、A3分别了百位、十位、个位数值
 299          *        3.控制段选信号dula和位选信号wela,以使数码管显示
 300          ***********************************************************/
 301          void display(uint temp)       //显示程序
 302          {
C51 COMPILER V9.57.0.0   MAIN                                                              10/01/2019 15:55:38 PAGE 6   

 303   1         uchar A1,A2,A2t,A3,ser;
 304   1         ser=temp/10;
 305   1         SBUF=ser;
 306   1         A1=temp/100;               //A1 --> 百位
 307   1         A2t=temp%100;              //A2t --> 后两位
 308   1         A2=A2t/10;                 //A2 --> 十位
 309   1         A3=A2t%10;                 //A3 --> 个位
 310   1         
 311   1        // 控制数码管显示温度数值
 312   1        P1 |= 0x0f;
 313   1        SendByte_74HC164(A1);
 314   1        P1 &= 0xfB;
 315   1        delay_ms(6);
 316   1        P1 |= 0x0f;
 317   1        
 318   1        SendByte_74HC164(A2);
 319   1        P1 &= 0xfD;
 320   1        delay_ms(6);
 321   1        P1 |= 0x0f;
 322   1        
 323   1        SendByte_74HC164(A3);
 324   1        P1 &= 0xfE;
 325   1        delay_ms(6);
 326   1      }
 327          
 328          
 329          void main()
 330          {
 331   1        uchar a;
 332   1        do
 333   1        {
 334   2          tmpchange();              //首次温度转换
 335   2          //delay(200);
 336   2          for(a=10;a>0;a--)       //延时,保持连续显示
 337   2          {
 338   3            uint num = tmp();
 339   3            display(num);         //进行温度转换和数值显示
 340   3          }
 341   2        }while(1);
 342   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    558    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      2       8
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
