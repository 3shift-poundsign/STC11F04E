C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 1   


C51 COMPILER V9.57.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: E:\keil\install\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listings
                    -\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <reg52.h>
   2          #define uchar unsigned char
   3          #define uint unsigned int
   4          sbit DS = P1^7;         //define interface
   5          uint temp;              //variable of temperature
   6          uchar flag1;            //sign of the result positive or negative
   7          sbit dula = P2^6;       //定义数码管段选使能
   8          sbit wela = P2^7;       //定义数码管位选使能
   9          //定义数码管字符集
  10          unsigned char code table[]={0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f,0x77,0x7c,0x39,0x5e,0x79,0x7
             -1};
  11          //定义数码管段选
  12          unsigned char code table1[]={0x81,0xD7,0xC8,0xC2,0x96,0xA2,0xA0,0xC7,0x80,0x82};
  13          
  14          
  15          
  16          /**********************************************************
  17          *  函数名称：延时函数
  18          *  修改日期：2019-9-9
  19          *  修改人：ZhangHJ
  20          *  说明：低精度延时函数
  21          ***********************************************************/
  22          void delay(uint count)  //delay function
  23          {
  24   1        uint i;
  25   1        while(count)
  26   1        {
  27   2          i=200;
  28   2          while(i>0)
  29   2          i--;
  30   2          count--;
  31   2        }
  32   1      }
  33          
  34          
  35          
  36          
  37          /**********************************************************
  38          *  函数名称：发送复位和初始化命令函数 dsinit
  39          *  修改日期：2019-9-9
  40          *  修改人：ZhangHJ
  41          *  说明：1. 对于单片机: 单片机首先发出480-960us的低电平脉冲,
  42          *           释放总线为高电平(上拉电阻拉高),在随后的480us进行检测,
  43          *           如果出现低电平，说明器件应答正常.B
  44          *        2. 对于DS18B20: 上电后就检测是否有480/960us的低电平脉冲,
  45          *           如果有低电平,在总线释放之后，等待15-60us,
  46          *           将电平拉低60-240us,告诉主机已经准备好.
  47          ***********************************************************/
  48          void dsreset(void)        //send reset and initialization command
  49          {
  50   1        uint i;
  51   1        DS = 0;               //先将端口拉低
  52   1        i=103;                //维持低电平状态480us~960us
  53   1        while(i>0)i--;
C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 2   

  54   1        DS = 1;               //然后释放总线(将总线拉高),若DS18B20做出反应,将会将在15us~60us后将总线拉低
  55   1        i = 4;                //15us~60us等待
  56   1        while(i>0)i--;
  57   1      //  while(DS);
  58   1      //  i = 0;
  59   1      //  while(DS)             //在DS高电平时等待
  60   1      //  {
  61   1      //    i++;
  62   1      //    if(i > 5000)        //等待时间大于60us,说明响应失败
  63   1      //    {
  64   1      //      reutrn 0;
  65   1      //    }
  66   1      //  }
  67   1      //  return 1;
  68   1      }
  69          
  70          
  71          
  72          /**********************************************************
  73          *  函数名称：读1bit数据函数
  74          *  修改日期：2019-9-9
  75          *  修改人：ZhangHJ
  76          *  说明：1.首先单片机端口拉低 1 us (i++),
  77          *        2.然后释放总线,拉高总线,
  78          *        3.等待几位秒，是为了让 DS18B20 数据稳定,
  79          *        4.在15 us 内读取DS数据,
  80          *        5.接下来进行延时等待采样周期完成。
  81          *        详见DS18B20资料2.8.3.1读/写时间片
  82          ***********************************************************/
  83          bit tmpreadbit(void)    //read a bit data
  84          {
  85   1        uint i;
  86   1        bit dat;              //定义位数据 (dat = 0 or 1)
  87   1        DS = 0;               //先将端口拉低
  88   1        i++;                  //延时 1us
  89   1        DS = 1;               //再将端口拉高
  90   1        i++;i++;              //等待DS数据稳定
  91   1        dat = DS;             //数据传输
  92   1        i=8;while(i>0)i--;    //等待数据采样周期完成
  93   1        return (dat);
  94   1      }
  95          
  96          
  97          
  98          /**********************************************************
  99          *  函数名称：读1Byte数据函数
 100          *  修改日期：2019-9-9
 101          *  修改人：ZhangHJ
 102          *  说明：1.首先初始化字节数据变量dat为 0
 103          *        2.循环 8 次,调用tmpreadbit函数,读 8bit 数据
 104          *        3.读出的数据暂存到 j ,之后进行移位和按位或操作
 105          *        4.效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
 106          *        5.最后返回读到的字节数据
 107          ***********************************************************/
 108          uchar tmpread(void)         //read a byte date
 109          {
 110   1        uchar i,j,dat;
 111   1        dat = 0;                  //初始化数据变量为 0
 112   1        for(i=1;i<=8;i++)         //循环 8 次,调用tmpreadbit函数,读 8bit 数据
 113   1        {
 114   2          j = tmpreadbit();       //读出的数据暂存到 j
 115   2          dat = (j<<7)|(dat>>1);  //效果是 j 先读入的数据,放到了dat的低位,读8次正好是1byte.
C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 3   

 116   2        }
 117   1        return(dat);              //返回读到的字节
 118   1      }
 119          
 120          
 121          
 122          /**********************************************************
 123          *  函数名称：写入1Byte数据函数
 124          *  修改日期：2019-9-11
 125          *  修改人：ZhangHJ
 126          *  说明：1.将对待写入数据dat进行位操作,将dat末位数值赋值给位数据testb
 127          *        2.通过判断testb得到写 0 还是写 1
 128          *        3.若是写 0 操作,将 DS 拉低,进行<60us的延时,再将DS拉高,进行>1us的延时
 129          *        4.若是写 1 操作,将 DS 拉低,进行>1us的延时,再将DS拉高,进行<60us的延时
 130          *        5.循环执行2、3、4操作8次,写入1字节数据
 131          *        详见18B20资料“2.8.3.1读/写时间片”章节
 132          ***********************************************************/
 133          void tmpwritebyte(uchar dat)   //write a byte to ds18b20
 134          {
 135   1        uint i;
 136   1        uchar j;
 137   1        bit testb;
 138   1        for(j=1;j<=8;j++)
 139   1        {
 140   2          testb = dat&0x01;
 141   2          dat = dat>>1;
 142   2          if(testb)                 //write 1
 143   2          {
 144   3            DS=0;
 145   3            i++;i++;
 146   3            DS=1;
 147   3            i=8;while(i>0)i--;
 148   3          }
 149   2          else
 150   2          {
 151   3            DS = 0;                 //write 0
 152   3            i=8;while(i>0)i--;
 153   3            DS=1;
 154   3            i++;i++;
 155   3          }
 156   2        }
 157   1      }
 158          
 159          
 160          
 161          /**********************************************************
 162          *  函数名称：18B20温度转换函数
 163          *  修改日期：2019-9-11
 164          *  修改人：ZhangHJ
 165          *  说明：1.首先进行18B20初始化
 166          *        2.进行适当延时
 167          *        3.发送跳过光刻ROM指令
 168          *        4.发送RAM指令,进行温度转换
 169          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 170          ***********************************************************/
 171          void tmpchange(void)          //DS18B20 begin change
 172          {
 173   1        dsreset();
 174   1        delay(1);
 175   1        tmpwritebyte(0xcc);         //address all drivers on bus
 176   1        tmpwritebyte(0x44);         //initiates a single temperature conversion
 177   1        //delay(100);               //not wait to change finish
C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 4   

 178   1      }
 179          
 180          
 181          
 182          /**********************************************************
 183          *  函数名称：18B20温度转换完整过程函数
 184          *  修改日期：2019-9-11
 185          *  修改人：ZhangHJ
 186          *  说明：1.首先进行18B20初始化
 187          *        2.进行适当延时
 188          *        3.发送跳过光刻ROM指令
 189          *        4.发送RAM指令,进行温度转换
 190          *        5.读取两个8位数据,放到16位寄存器 temp 中
 191          *        6.将读取到的二进制数据(默认为正数),转换为十进制数据
 192          *        7.返回温度数据
 193          *        详见18B20资料“2.8.3.1存储器操作命令”章节
 194          ***********************************************************/
 195          uint tmp()                    //get the temperature
 196          {
 197   1        float tt;
 198   1        uchar a,b;
 199   1        dsreset();
 200   1        delay(1);
 201   1        tmpwritebyte(0xcc);         //读暂存寄存器
 202   1        tmpwritebyte(0xbe);
 203   1        a=tmpread();
 204   1        b=tmpread();
 205   1        temp=b;
 206   1        temp<<=8;                   //two byte compose a int variable
 207   1        temp=temp|a;
 208   1        tt=temp*0.0625;
 209   1        temp=tt*10+0.5;
 210   1        return temp;
 211   1      }
 212          
 213          
 214          
 215          /**********************************************************
 216          *  函数名称：读取ROM函数
 217          *  修改日期：2019-9-11
 218          *  修改人：ZhangHJ
 219          *  说明：使单片机读取DS18B20产品的序列号,暂时没有用到
 220          *        详见18B20资料“2.8.2.2ROM操作命令”章节
 221          ***********************************************************/
 222          //void readrom()                //read the serial
 223          //{
 224          //  uchar sn1,sn2;
 225          //  dsreset();
 226          //  delay(1);
 227          //  tmpwritebyte(0x33);
 228          //  sn1=tmpread();
 229          //  sn2=tmpread();
 230          //}
 231          
 232          
 233          
 234          /**********************************************************
 235          *  函数名称：10ms延时函数
 236          *  修改日期：2019-9-11
 237          *  修改人：ZhangHJ
 238          *  说明：延时10ms
 239          *        详见18B20资料“2.8.2.2ROM操作命令”章节
C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 5   

 240          ***********************************************************/
 241          //void delay10ms()              //delay 10ms
 242          //{
 243          //  uchar a,b;
 244          //  for(a=10;a>0;a--)
 245          //    for(b=60;b>0;b--);
 246          //}
 247          
 248          
 249          
 250          /**********************************************************
 251          *  函数名称：数码管温度数据显示函数
 252          *  修改日期：2019-9-11
 253          *  修改人：ZhangHJ
 254          *  说明：1.temp表示需要显示的温度数值(百位数值)
 255          *        2.A1、A2、A3分别了百位、十位、个位数值
 256          *        3.控制段选信号dula和位选信号wela,以使数码管显示
 257          ***********************************************************/
 258          void display(uint temp)       //显示程序
 259          {
 260   1         uchar A1,A2,A2t,A3,ser;
 261   1         ser=temp/10;
 262   1         SBUF=ser;
 263   1         A1=temp/100;               //A1 --> 百位
 264   1         A2t=temp%100;
 265   1         A2=A2t/10;                 //A2 --> 十位
 266   1         A3=A2t%10;                 //A3 --> 个位
 267   1         dula=0;
 268   1         P0=table[A1];              //显示百位
 269   1         dula=1;
 270   1         dula=0;
 271   1      
 272   1         wela=0;
 273   1         P0=0xfe;
 274   1         wela=1;
 275   1         wela=0;
 276   1         delay(1);
 277   1      
 278   1         dula=0;
 279   1         P0=table1[A2];             //显示十位
 280   1         dula=1;
 281   1         dula=0;
 282   1      
 283   1         wela=0;
 284   1         P0=0xfd;
 285   1         wela=1;
 286   1         wela=0;
 287   1         delay(1);
 288   1      
 289   1         P0=table[A3];              //显示个位
 290   1         dula=1;
 291   1         dula=0;
 292   1      
 293   1         P0=0xfb;
 294   1         wela=1;
 295   1         wela=0;
 296   1         delay(1);
 297   1      }
 298          
 299          
 300          
 301          void main()
C51 COMPILER V9.57.0.0   MAIN                                                              09/30/2019 10:00:12 PAGE 6   

 302          {
 303   1        uchar a;
 304   1        do
 305   1        {
 306   2          tmpchange();              //首次温度转换
 307   2          //delay(200);
 308   2          for(a=100;a>0;a--)        //延时,保持连续显示
 309   2          {
 310   3            display(tmp());         //进行温度转换和数值显示
 311   3          }
 312   2        }while(1);
 313   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    466    ----
   CONSTANT SIZE    =     26    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      3       6
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
